import bpy
import os


# import one of Alice's cool 3d files
"""eventually this needs to be recompiled as an iterative function that takes the file name of the .glb file, imports it, and selects it for editing"""

bpy.ops.import_scene.gltf(
    filepath="Uluaq_12147.glb",
    files=[{"name": "Uluaq_12147.glb", "name": "Uluaq_12147.glb"}],
    loglevel=50,
)


bpy.ops.object.shade_smooth()

bpy.data.objects["Uluaq_12147"].select_set(True)

# Shades objects (show's 3D model color)
for area in bpy.context.screen.areas:
    if area.type == "VIEW_3D":
        for space in area.spaces:
            if space.type == "VIEW_3D":
                space.shading.type = "MATERIAL"


def resize(path):
    """this function takes the object name and resizes it. The relative size of the transformation should be calculated in pixels if possible to ensure that it does not conflict with syntehtic.py. Blender calculates relative size in meters, but our YOLO classifier will deal in pixels. Thus the resizer is based on a scaled x-height of 1500 pixels"""
    px = 377.9527559055  # one meter is 377.95 pixels
    bpy.data.objects[path].select_set(True)
    meters = bpy.context.object.dimensions[
        0
    ]  # produces a vector of object size in X,Y,Z Format. We are only taking the measurement for x since we will scale the o   bject by height
    pixels = meters * px
    x_height = 1500  # might want to change this
    scale_size = x_height // pixels
    print(
        "\n The selected model size is:",
        str(meters),
        "meters",
        "\n This translates to",
        str(pixels),
        "pixels",
        "\n The selected model will be scaled by a factor of:",
        str(scale_size),
    )
    bpy.ops.transform.resize(
        value=(scale_size, scale_size, scale_size),
        orient_type="GLOBAL",
        orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)),
        orient_matrix_type="GLOBAL",
        mirror=False,
        use_proportional_edit=False,
        proportional_edit_falloff="SMOOTH",
        proportional_size=1,
        use_proportional_connected=False,
        use_proportional_projected=False,
        snap=False,
        snap_elements={"INCREMENT"},
        use_snap_project=False,
        snap_target="CLOSEST",
        use_snap_self=True,
        use_snap_edit=True,
        use_snap_nonedit=True,
        use_snap_selectable=False,
    )


resize("Uluaq_12147")


def delete_cube():
    """deletes the cube that is autogenerated by Blender"""
    bpy.ops.object.select_all(action="DESELECT")
    bpy.data.objects["Cube"].select_set(True)
    bpy.ops.object.delete(use_global=False, confirm=False)


delete_cube()


def light_aug():
    """this function augments the position of the light source. The location and light intensity could be randomized"""
    # Delete old light
    bpy.ops.object.select_by_type(type="LIGHT")
    bpy.ops.object.delete(use_global=False)

    view_layer = bpy.context.view_layer

    # Create new light datablock.
    light_data = bpy.data.lights.new(name="New Light", type="POINT")
    light_data.energy = 10000

    # Create new object with our light datablock.
    light_object = bpy.data.objects.new(name="New Light", object_data=light_data)

    # Link light object to the active collection of current view layer,
    # so that it'll appear in the current scene.
    view_layer.active_layer_collection.collection.objects.link(light_object)

    # Place light to a specified location.
    light_object.location = (7.68889, -6.78579, 4.08386)
    light_object.rotation_euler = (-0.29215, 15.3403, -0.555648)

    # And finally select it and make it active.
    light_object.select_set(True)
    view_layer.objects.active = light_object
    # Sets the location of the light so that object is illuminated
    print(list(bpy.data.objects))


light_aug()

cam_loc = bpy.data.objects["Camera"].location
cam_rot = bpy.data.objects["Camera"].rotation_euler

print(cam_rot)

# render a png of image
def render_obj(path):
    """this takes the path e.g., Uluaq_12147" as an argument"""
    #changes the background to white
    world = bpy.data.worlds['World']
    world.use_nodes = True
    #bpy.context.scene.view_settings.view_transform = 'Standard'#bpy.context.scene.render.film_transparent= True
    bpy.context.scene.view_settings.view_transform = 'Standard'
    bg = world.node_tree.nodes['Background']
    bg.inputs[0].default_value = (1, 1, 1, 1)
    bg.inputs[1].default_value = 1.0
    bpy.data.objects[path].select_set(True)
    bpy.context.scene.render.filepath = "test.png"
    bpy.ops.render.render(write_still=True)
    #change object color to black for mask
    bpy.ops.object.shade_smooth()
    bpy.ops.object.select_all(action='DESELECT')
    bpy.data.objects[path].select_set(True)
    for area in bpy.context.screen.areas:
        if area.type == "VIEW_3D":
            for space in area.spaces:
                if space.type == "VIEW_3D":
                    space.shading.type = "MATERIAL"
    #change active object to path (e.g., "Uluaq1214")
    ob=bpy.context.view_layer.objects.active
    ob=bpy.data.objects[path]
    mat = bpy.data.materials.new(name="mask")
    mat.use_nodes=True
    ''''need to make the black solid--like a mask. Right now it is not.'''
    mat.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = (0, 0, 0, 0)
    ob.data.materials.append(mat)
    ob.active_material = mat
    print(list(ob.data.materials.items()))
    print(list(ob.material_slots))
    bpy.context.collection.objects.link(ob)
    bpy.context.scene.render.filepath="mask.png"
    bpy.ops.render.render(write_still=True)


render_obj("Uluaq_12147")

bpy.ops.object.select_all(action='DESELECT')


# render a mask of the image

def render_mask(path):
    '''renders a mask of the image. Takes a path from blender as an argument e.g, "Uluaq_12147"'''
   
    bpy.ops.object.select_all(action='DESELECT')
    obj = bpy.context.scene.objects[path]
    bpy.data.objects[path].select_set(True)
    bpy.context.object.is_holdout = True
    print(str(bpy.context.object))
    #changes the background to white
    #world = bpy.data.worlds['World']
    #world.use_nodes = True
    #bpy.context.scene.view_settings.view_transform = 'Standard'#bpy.context.scene.render.film_transparent= True
    #bpy.context.scene.view_settings.view_transform = 'Standard'
    #bg = world.node_tree.nodes['Background']
    #bg.inputs[0].default_value = (1, 1, 1, 1)
    #bg.inputs[1].default_value = 1.0
    bpy.context.scene.render.filepath = "mask.png"
    bpy.ops.render.render(write_still=True)


#render_mask("Uluaq_12147")

