import bpy
import os


# import one of Alice's cool 3d files
"""eventually this needs to be recompiled as an iterative function that takes the file name of the .glb file, imports it, and selects it for editing"""

bpy.ops.import_scene.gltf(
    filepath="Uluaq_12147.glb",
    files=[{"name": "Uluaq_12147.glb", "name": "Uluaq_12147.glb"}],
    loglevel=50,
)
bpy.ops.object.shade_smooth()

bpy.data.objects["Uluaq_12147"].select_set(True)

# Shades objects (show's 3D model color)
for area in bpy.context.screen.areas:
    if area.type == "VIEW_3D":
        for space in area.spaces:
            if space.type == "VIEW_3D":
                space.shading.type = "MATERIAL"


def resize(path):
    """this function takes the object name and resizes it. The relative size of the transformation should be calculated in pixels if possible to ensure that it does not conflict with syntehtic.py. Blender calculates relative size in meters, but our YOLO classifier will deal in pixels. Thus the resizer is based on a scaled x-height of 1500 pixels"""
    px = 377.9527559055  # one meter is 377.95 pixels
    bpy.data.objects[path].select_set(True)
    meters = bpy.context.object.dimensions[
        0
    ]  # produces a vector of object size in X,Y,Z Format. We are only taking the measurement for x since we will scale the o   bject by height
    pixels = meters * px
    x_height = 1500  # might want to change this
    scale_size = x_height // pixels
    print(
        "\n The selected model size is:",
        str(meters),
        "meters",
        "\n This translates to",
        str(pixels),
        "pixels",
        "\n The selected model will be scaled by a factor of:",
        str(scale_size),
    )
    bpy.ops.transform.resize(
        value=(scale_size, scale_size, scale_size),
        orient_type="GLOBAL",
        orient_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)),
        orient_matrix_type="GLOBAL",
        mirror=False,
        use_proportional_edit=False,
        proportional_edit_falloff="SMOOTH",
        proportional_size=1,
        use_proportional_connected=False,
        use_proportional_projected=False,
        snap=False,
        snap_elements={"INCREMENT"},
        use_snap_project=False,
        snap_target="CLOSEST",
        use_snap_self=True,
        use_snap_edit=True,
        use_snap_nonedit=True,
        use_snap_selectable=False,
    )


resize("Uluaq_12147")


def delete_cube():
    """deletes the cube that is autogenerated by Blender"""
    bpy.ops.object.select_all(action="DESELECT")
    bpy.data.objects["Cube"].select_set(True)
    bpy.ops.object.delete(use_global=False, confirm=False)


delete_cube()


def light_aug():
    """this function augments the position of the light source. The location and light intensity could be randomized"""
    # Delete old light
    bpy.ops.object.select_by_type(type="LIGHT")
    bpy.ops.object.delete(use_global=False)

    view_layer = bpy.context.view_layer

    # Create new light datablock.
    light_data = bpy.data.lights.new(name="New Light", type="POINT")
    light_data.energy = 10000

    # Create new object with our light datablock.
    light_object = bpy.data.objects.new(name="New Light", object_data=light_data)

    # Link light object to the active collection of current view layer,
    # so that it'll appear in the current scene.
    view_layer.active_layer_collection.collection.objects.link(light_object)

    # Place light to a specified location.
    light_object.location = (7.68889, -6.78579, 4.08386)
    light_object.rotation_euler = (-0.29215, 15.3403, -0.555648)

    # And finally select it and make it active.
    light_object.select_set(True)
    view_layer.objects.active = light_object
    # Sets the location of the light so that object is illuminated
    print(list(bpy.data.objects))


light_aug()

cam_loc = bpy.data.objects["Camera"].location
cam_rot = bpy.data.objects["Camera"].rotation_euler

print(cam_rot)


world = bpy.data.worlds['World']
world.use_nodes = True


#bpy.context.scene.view_settings.view_transform = 'Standard'#bpy.context.scene.render.film_transparent= True
bpy.context.scene.view_settings.view_transform = 'Standard'
bg = world.node_tree.nodes['Background']
bg.inputs[0].default_value = (1, 1, 1, 1)
bg.inputs[1].default_value = 1.0



# Renders a .png of the file
"""still need to make the colors correct (white background & black mask"""


"""
#enables a white background for .png file
having trouble here. based on youtube tutorial @ https://www.youtube.com/watch?v=aegiN7XeLow 
will need to trouble shoot context issue which appears in line 66

x=bpy.context.use_nodes
print(str(x))
bpy.context.scene.render.film_transparent = True
bpy.context.scene.view_settings.view_transform = 'Standard'
bpy.context.scene.use_nodes = True
#bpy.ops.object.select_all(action="SELECT")

x=bpy.context.selected_objects
print(str(x))
#bpy.ops.node.add_node(use_transform=True, type="CompositorNodeAlphaOver")
"""


# render a png of image
def render_obj(path):
    """this takes the path e.g., Uluaq_12147" as an argument"""
    bpy.data.objects[path].select_set(True)
    bpy.context.scene.render.filepath = "test.png"
    bpy.ops.render.render(write_still=True)


render_obj("Uluaq_12147")


# render a mask of the image
def render_maske(path):
    '''renders a mask of the image. Takes a path from blender as an argument e.g, "Uluaq_12147"'''
    bpy.data.objects[path].select_set(True)
    bpy.context.object.is_holdout = True
    bpy.ops.object.select_all(action="SELECT")
    bpy.context.scene.render.filepath = "mask.png"
    bpy.ops.render.render(write_still=True)
